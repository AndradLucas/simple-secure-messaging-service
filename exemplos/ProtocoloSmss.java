/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package exemplos;

import java.io.UnsupportedEncodingException;

import protocols.ProtocolModel;
import util.Util;

/**
 * Suponha que o protocolo deve trocar 4 mensagens.
 * Cliente envia byte de valor X
 * Servidor retorna byte de valor X+1
 * Cliente envia byte de valor (X+2)+tamanho da mensagem(1 bytes)+mensagem de texto
 * Servidor retorna byte de valor (X+3)+1 byte de código de erro (ou zero se sucesso)
 * Código de erro: 1 para erro no indice X+i e 2 para erro na mensagem ou tamanho
 * @author yeda
 */
public class ProtocoloSmss extends ProtocolModel {
    private int valor = 0;
    private boolean errorMsg = false;
    
    private String texto = "Texto nao obtido ainda";
    private String initializationArray = "iv nao iniciado ainda";
	private String textoCriptografado = "Texto criptografado nao obtido ainda";

    /* dados do protocolo smss: */
    private int origem = 743563;
    private int destino = 743563;
    private int tipo = 0;
    private int algoritmo = -1;
    private int padding = -1;
    private int modo = -1;
    
    public Util util;
    
    
    /**
     * Servidor e cliente no modo padrão.
     * 
     * @param mode
     */
    ProtocoloSmss(int mode) {
        // gera um protocolo com 4 mensagens, alternando entre enviar e receber
        // Modo cliente, inicia com enviar, e modo servidor, incia com receber
        super(mode, 4);
    }
    
    /**
    * Este método deve retornar as mensagens exatamente como especificado
    * pelo protocolo. 
    * Cliente gera as mensagens: 0 e 2
    * Servidor gera as mensagens: 1 e 3
    * Todas as mensagens geradas são implementadas nesta classe, nos
    * respectivos métodos privados gen??Message()
    * Obs.:Para um protocolo de 4 mensagens este método não precisa ser editado
    */
    protected byte[] nextMessage() {
        byte[] msg = null;
        switch (this.step) {
            case 0:
                //First message, generated by the CLIENT
            	// Par_req
                msg = this.genFirstMessage();
                System.out.println("Primeira Msg sent...");
                //Util.viewHex(msg);
                break;
            case 1:
                //Second message, genereted by the SERVER
                msg = this.genSecondMessage();
                System.out.println("Segunda Msg sent...");
                //Util.viewHex(msg);
                break;
            case 2:
                //Third message, generated by the CLIENT
                msg = this.genThirdMessage();
                System.out.println("Terceira Msg sent...");
                //Util.viewHex(msg);
                break;
            case 3:
                //Third message, generated by the CLIENT
                msg = this.genForthMessage();
                System.out.println("Quarta Msg sent...");
                //Util.viewHex(msg);
                break;
        }
        
        return msg;
    }

    /**
    * Este método valida se as mensagens recebidas são exatamente como
    * especificado pelo protocolo. 
    * Cliente valida as mensagens: 1 e 3
    * Servidor valida as mensagens: 0 e 2
    * Todas as validações de mensagens são implementadas nesta classe, nos
    * respectivos métodos privados verify??Message()
    * Obs.:Para um protocolo de 4 mensagens este método não precisa ser editado
    */
    protected boolean verifyMessage(byte[] receivedMsg) {
        boolean ret = false;
        switch (this.step) {
            case 0:
                //Verify First message, performed by the SERVER
                ret = this.verifyFirstMessage(receivedMsg);
                System.out.println("Primeira Msg ... " + ret);
                break;
            case 1:
                //Verify Second message, performed by the CLIENT
                ret = this.verifySecondMessage(receivedMsg);
                System.out.println("Segunda Msg ... " + ret);
                break;
            case 2:
                //Verify Third message, performed by the SERVER
                ret = this.verifyThirdMessage(receivedMsg);
                System.out.println("Terceira Msg ... " + ret);
                break;
            case 3:
                //Verify Third message, performed by the SERVER
                ret = this.verifyForthMessage(receivedMsg);
                System.out.println("Terceira Msg ... " + ret);
                break;
        }
        
        return ret;
    }

    private byte[] genFirstMessage(){
        // definição do tamanho da mensagem
        byte[] ret = new byte[7];
        // atribuiçao correta dos bytes da mensagem
        // para o exemplo, envia um número qualquer de 1 byte
        // valor deve ser definido em setMessage()
        
        //ret[0] = (byte)this.valor;
        
        /* [ALTERADO] */
        ret[0] = (byte) this.tipo;
        ret[1] = (byte) (this.origem >> 8);
        ret[2] = (byte) (this.origem);
        ret[3] = (byte) (this.destino >> 8);
        ret[4] = (byte) (this.destino);
        ret[5] = (byte) ((this.algoritmo << 4 ) | (this.padding));
        ret[6] = (byte) (this.modo);
        
        
        
        return ret;
    }
    
    private byte[] genSecondMessage(){
        // definição do tamanho da mensagem
        byte[] ret = new byte[17];
        int erro;
        
        /* [ALTERADO][COMPLETAR]
         * Aqui precisamos responder pro cliente informando ou a chave de seguranca, ou  o codigo de erro.
         * Voce precisa ver qual criterio de criptografia vai querer aceitar, abaixo faço uma checagem
         * bem basica.
         * 
         * Voce tambem precisa gerar o IV  enfiar no vetor de mesmo nome:
         */
        String initializationArray = "Isso eh um teste";
        
        int tamanhoIV = initializationArray.length();
        
        if( this.modo == 5 && this.algoritmo == 0 && this.padding == 0) {
        	erro = 0;
        }else {
        	erro = 1;
        }
        
        // atualização dos parametros internos do protocol
        this.valor = this.valor+1;
        // atribuiçao correta dos bytes da mensagem
        // para o exemplo, envia o incremento do valor recebido e
        // atualizado na verificação
        
        // monto o array de retorno parConf:
        ret[0] =  (byte) ((this.step << 4 ) | (erro));
     	
        byte[] bytesIV = new byte[tamanhoIV];
        
		try {
			bytesIV = initializationArray.getBytes("UTF-8");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
     	
     	int j = 1;
     	for( int i=0; i < bytesIV.length; i++) {
     		ret[j] = bytesIV[i];
     		j++;
     	}
     				
        return ret;
    }
    
    private byte[] genThirdMessage(){    	
    	
    	String mensagemDeTexto = this.texto;
    	
    	int tamanhoTexto = mensagemDeTexto.length();
    	
    	int i = 0;
    	   	
    	/* [ALTERADO][COMPLETAR]
    	 * aqui eu vou enviar a mensagem, que suponho esta salva no atributo referente a mensagem,
    	 * pro servidor.Na realidade, devemos mandar a mensagem criptografada, e eu to
    	 * esperando que voce criptografe ela aqui antes do envio e salve na variavel "criptografada"
    	 * 
    	 * Lembra que o IV foi recebido e salvo num atributo no verifySecnondMessage (linha 265).
    	 */
    	byte[] criptografadaBytes = new byte[tamanhoTexto];
    	
    	// Vou converter de string para byte array:
    	try {
    		criptografadaBytes = mensagemDeTexto.getBytes("UTF-8");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
        
        // começar o prenchimento da mensagem "Dados":
    	
        // definição do tamanho da mensagem
        byte[] ret = new byte[3 + tamanhoTexto];
        
        // codigo de erro zero e tipo da mensagem no primeiro byte:
        ret[0] = (byte) ((this.tipo << 4) | 0);

        // tamanho da mensagem nos bytes 1 e 2:
        ret[1] = (byte) (mensagemDeTexto.length() >> 8);
        ret[2] = (byte) (mensagemDeTexto.length());
		
        // a partir dai, inserir a mensagem criptografada:
        int j = 3;
        for (i = 0; i < tamanhoTexto; i++) {
        	ret[j] = criptografadaBytes[i];
        	j++;
        } 
        
        return ret;
    }
    
    private byte[] genForthMessage(){
        
    	byte[] ret = new byte[1];
    	String criptografada = this.textoCriptografado;
    	
    	this.valor = this.valor+1;
    	boolean descriptografia =  true;
    	/* [COMPLETAR]
    	 * Aqui a gente tenta decifrar a mensagem criptorafada.
    	 * Alternativamente voce pode decifrar ela no validateThirdMessage, se achar que fica melhor...
    	 * Se conseguirmos validar, respondemos pro cliente confirmando 
    	 */
    	String descriptografada = criptografada;
    	
    	// adicionar validacao: this.tipo deve ser 4 aqui...
    	if(descriptografia) {
    		this.setMensagem(descriptografada);
    		ret[0] = (byte) ((4 << 4) | 0);
    	}
    		
 	/** codigo yeda **
    	// definição do tamanho da mensagem
        byte[] ret = new byte[2];
        // atualização dos parametros internos do protocol
        this.valor = this.valor+1;
        // atribuiçao correta dos bytes da mensagem
        // para o exemplo, envia o incremento do valor recebido e
        // atualizado na verificação
        ret[0] = (byte)this.valor ;
        ret[1] = (byte)this.getErrorCode();
        **/
    	return ret;
    }
    
    private boolean verifyFirstMessage(byte[] msg){
    	
    	// VALIDAR OS PARAMETROS DE CRIPTOGRAFIA:
    	this.algoritmo = ( msg[5] >> 4);
    	this.padding = (msg[5] & 15);
    	this.tipo = 1;
    	this.modo = (int) msg[6];
    	System.out.println("[Par_req] algoritmo: " + this.algoritmo + ", padding: " + this.padding + ", tipo: " 
    						+ this.tipo + " , modo: " + this.modo);
    	
        // 1a mensagem sempre correta
        boolean ret = true;
        // atualização do status do protocolo, para o caso de enviar mensagem de erro
        this.errorMsg = false;
        // atualiza o estado das informações recebidas
        this.valor = (int)msg[0];
        this.tipo = (int)msg[0];
        
        return ret;
    }

    private boolean verifySecondMessage(byte[] msg){
        
    	int i,j;
		byte[] initializationArray = new byte[16];
    	
    	// mensagem, provavelmente, correta
        boolean ret = true;
        this.errorMsg = false;
        
        // decompões mensagem nos parâmetros do protocolo para validação
        int tipo = (int) (msg[0] >> 4);
        int erro = (msg[0] & 15);
        
        System.out.print("[Par_conf] Tipo: " + tipo + ", Erro: " + erro );

        // analisa se mensagem recebido é valida, ou seja, possui a estrutura
        // esperada para o protocolo, é integra, etc.
        if( erro != 0) {
        	this.errorMsg = true;
        	ret = false;
        	this.setErrorCode(1);
        } else {
        	this.tipo = tipo;
        	
        	j = 1;
    		for(i = 0; i < 16; i++) {
    			initializationArray[i] = msg[j];
    			j++;
    		}
    		
    		this.initializationArray = util.byteToString(initializationArray);
    		System.out.println(", IV: " + this.initializationArray);
        }

        return ret;
    }
    
    private boolean verifyThirdMessage(byte[] msg){
        int i,j = 0;
        int tamanhoMsg = msg.length;
        
        byte[] bytesMensagemCriptografada = new byte[tamanhoMsg];
        
    	for (i=3;i<tamanhoMsg; i++) {
    		bytesMensagemCriptografada[j] = msg[i];
    		j++;
    	}
    	
    	String mensagemCriptografada = util.byteToString(bytesMensagemCriptografada);
    	
    	// recebo a mensagem criptografada do cliente:
    	System.out.println("[Dados] mensagem criptografada: " + mensagemCriptografada);
    	
    	this.setMensagemCriptografada(mensagemCriptografada);
    	
    	return true;
    	/** codigo yeda **
    	// mensagem, provavelmente, correta
        boolean ret = true;
        byte [] bStr;
        // decompões mensagem nos parâmetros do protocolo para validação
        int recebido = (int)msg[0];
        int len = (int)msg[1];
        
        this.errorMsg = false;
        
        
        // analisa se mensagem recebido é valida, ou seja, possui a estrutura
        // esperada para o protocolo, é integra, etc.
        // para o exemplo, se corresponde ao incremento do valor enviado
        if (recebido == (this.valor+1)) {
            this.valor = recebido;
            if (len == (msg.length-2)){
                bStr = new byte[len];
                System.arraycopy(msg, 2, bStr, 0, len);
                this.texto = new String(bStr);
            } else {
                this.errorMsg = true;
                // atribuir o código de erro para retorno, se existir
                this.setErrorCode(2);
                ret = false;
            }
        } else {
            this.errorMsg = true;
            ret = false;
            // atribuir o código de erro para retorno, se existir
            this.setErrorCode(1);
        }
        return ret;
        **/
    }
    
    private boolean verifyForthMessage(byte[] msg){
        
    	boolean ret = false;
    	this.tipo = ( msg[0] >> 4);
    	int erro = (msg[0] & 15);
    	
    	// adicionar validacao de tipo e tratamento de erro
    	if(erro == 0) {
    		ret = true;
    	}
    	
    	
    	/** codigo yeda **
    	// mensagem, provavelmente, correta
        this.errorMsg = false;
        
        // decompões mensagem nos parâmetros do protocolo para validação
        int recebido = (int)msg[0];
        
        // analisa se mensagem recebido é valida, ou seja, possui a estrutura
        // esperada para o protocolo, é integra, etc.
        // para o exemplo, se corresponde ao incremento do valor enviado
        if (recebido == (this.valor+1)) {
            this.valor = recebido;
        } else {
            this.errorMsg = true;
            ret = false;
            // atribuir o código de erro para retorno, se existir
            this.setErrorCode((int)msg[1]);
        }
        **/
        return ret;
    }
    
    /**
     * Este método informa ao RunProtocol o tamanho do cabeçalho
     * para leitura
     * @return 
     */
    public int getHeaderLenght() {
        int ret = 0;
        // Precisa reconhecer o tipo da mensagem e saber o tamanho
        // do cabeçalho e payload para leitura pelo RunProtocol
        //System.out.println("STEP: " + this.getStep());
        switch (this.getStep()) {
            case 0: ret = 1;break;
            case 1: ret = 1;break;
            case 2: ret = 3;break;
            case 3: ret = 2;break;
        }
        
        return ret;
    }

    /**
     * Este método informa ao RunProtocol o tamanho do payload
     * Em mensagens de tamanho variável esta informação está no cabeçalho
     * @param header
     * @return 
     */
    public int getPayloadLenght(byte[] header) {
        int ret = 0;
        // precisa reconhecer o tipo da mensagem e saber o tamanho
        // do cabeçalho e payload 
        
        switch (this.getStep()) {
            case 0: ret = 6;break;
            case 1: ret = 16;break;
            case 2: ret =  ((header[1] << 4 ) | (header[2]));
                    //System.out.println("Header: "+header[1]);
                    break;
            case 3: ret = 1;break;
        }
        return ret;
    }
    
    public String getMensagem(){
        return this.texto;
    }
    
    /**
     * Este método é específico deste exemplo
     * @param vlr 
     */
    public void setValor(int vlr){
        if (this.mode == CLIENT) {
            this.valor = vlr;
        }
    }
    
    public void setMensagem(String texto){
    	this.texto = texto;
    }
    
    public void setMensagemCriptografada(String texto){
        if (this.mode == SERVER) {
            this.textoCriptografado = texto;
        }
    }
    
    public void setAlgoritmo(byte algoritmo) {
    	if (this.mode == CLIENT) {
            this.algoritmo = algoritmo;
        }
    }
    
    public void setPadding(byte padding) {
    	if (this.mode == CLIENT) {
            this.padding = padding;
        }
    }
    
    public void setModo(int modo) {
    	if (this.mode == CLIENT) {
            this.modo = modo;
        }
    }
}
