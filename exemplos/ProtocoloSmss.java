/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package exemplos;

import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.HashMap;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;

import protocols.ProtocolModel;
import util.Util;

/**
 * Suponha que o protocolo deve trocar 4 mensagens.
 * Cliente envia byte de valor X
 * Servidor retorna byte de valor X+1
 * Cliente envia byte de valor (X+2)+tamanho da mensagem(1 bytes)+mensagem de texto
 * Servidor retorna byte de valor (X+3)+1 byte de c�digo de erro (ou zero se sucesso)
 * C�digo de erro: 1 para erro no indice X+i e 2 para erro na mensagem ou tamanho
 * @author yeda
 */
public class ProtocoloSmss extends ProtocolModel {
    private int valor = 0;
    private int errorCode = 0;
    private boolean errorMsg = false;
    private Cipher cipher;
    
    private String texto = "Texto nao obtido ainda";
    //private String initializationArray = "iv nao iniciado ainda";
    private byte[] initializationArray;
    private byte[] secretKey;
	private String textoCriptografado = "Texto criptografado nao obtido ainda";

    /* dados do protocolo smss: */
    private int origem = 743563;
    private int destino = 743563;
    private int tipo = 0;
    private int algoritmo = -1;
    private int padding = -1;
    private int modo = -1;
    
    public Util util;
    
    
    /**
     * Servidor e cliente no modo padr�o.
     * 
     * @param mode
     */
    ProtocoloSmss(int mode) {
        // gera um protocolo com 4 mensagens, alternando entre enviar e receber
        // Modo cliente, inicia com enviar, e modo servidor, incia com receber
        super(mode, 4);
    }
    
    /**
    * Este m�todo deve retornar as mensagens exatamente como especificado
    * pelo protocolo. 
    * Cliente gera as mensagens: 0 e 2
    * Servidor gera as mensagens: 1 e 3
    * Todas as mensagens geradas s�o implementadas nesta classe, nos
    * respectivos m�todos privados gen??Message()
    * Obs.:Para um protocolo de 4 mensagens este m�todo n�o precisa ser editado
    */
    protected byte[] nextMessage() {
        byte[] msg = null;
        switch (this.step) {
            case 0:
                //First message, generated by the CLIENT
            	// Par_req
                msg = this.genFirstMessage();
                System.out.println("Primeira Msg sent...");
                //Util.viewHex(msg);
                break;
            case 1:
                //Second message, genereted by the SERVER
                msg = this.genSecondMessage();
                System.out.println("Segunda Msg sent...");
                //Util.viewHex(msg);
                break;
            case 2:
                //Third message, generated by the CLIENT
                msg = this.genThirdMessage();
                System.out.println("Terceira Msg sent...");
                //Util.viewHex(msg);
                break;
            case 3:
                //Third message, generated by the CLIENT
                msg = this.genForthMessage();
                System.out.println("Quarta Msg sent...");
                //Util.viewHex(msg);
                break;
        }
        
        return msg;
    }

    /**
    * Este m�todo valida se as mensagens recebidas s�o exatamente como
    * especificado pelo protocolo. 
    * Cliente valida as mensagens: 1 e 3
    * Servidor valida as mensagens: 0 e 2
    * Todas as valida��es de mensagens s�o implementadas nesta classe, nos
    * respectivos m�todos privados verify??Message()
    * Obs.:Para um protocolo de 4 mensagens este m�todo n�o precisa ser editado
    */
    protected boolean verifyMessage(byte[] receivedMsg) {
        boolean ret = false;
        switch (this.step) {
            case 0:
                //Verify First message, performed by the SERVER
                ret = this.verifyFirstMessage(receivedMsg);
                System.out.println("Primeira Msg ... " + ret);
                break;
            case 1:
                //Verify Second message, performed by the CLIENT
                ret = this.verifySecondMessage(receivedMsg);
                System.out.println("Segunda Msg ... " + ret);
                break;
            case 2:
                //Verify Third message, performed by the SERVER
                ret = this.verifyThirdMessage(receivedMsg);
                System.out.println("Terceira Msg ... " + ret);
                break;
            case 3:
                //Verify Third message, performed by the SERVER
                ret = this.verifyForthMessage(receivedMsg);
                System.out.println("Terceira Msg ... " + ret);
                break;
        }
        
        return ret;
    }

    private byte[] genFirstMessage(){
        // definição do tamanho da mensagem
        byte[] ret = new byte[7];
        
        // atribuição correta dos bytes da mensagem
        // para o exemplo, envia um n�mero qualquer de 1 byte
        // valor deve ser definido em setMessage()
        
        //ret[0] = (byte)this.valor;
        
        /* [ALTERADO] */
        ret[0] = (byte) this.tipo;
        ret[1] = (byte) (this.origem >> 8);
        ret[2] = (byte) (this.origem);
        ret[3] = (byte) (this.destino >> 8);
        ret[4] = (byte) (this.destino);
        ret[5] = (byte) ((this.algoritmo << 4 ) | (this.padding));
        ret[6] = (byte) (this.modo);
        
        
        
        return ret;
    }
    
    private byte[] genSecondMessage(){
        // defini��o do tamanho da mensagem
        byte[] ret = new byte[17];
        int erro;
        
        /* [ALTERADO][COMPLETAR]
         * Aqui precisamos responder pro cliente informando ou a chave de seguranca, ou  o codigo de erro.
         * Voce precisa ver qual criterio de criptografia vai querer aceitar, abaixo fa�o uma checagem
         * bem basica.
         * 
         * Voce tambem precisa gerar o IV  enfiar no vetor de mesmo nome:
         */
        String initializationArray = "Isso eh um teste";
        
        int tamanhoIV = initializationArray.length();
        
        if( this.modo == 5 && this.algoritmo == 0 && this.padding == 0) {
        	erro = 0;
        }else {
        	erro = 1;
        }
        
        // atualiza��o dos parametros internos do protocol
        this.valor = this.valor+1;
        // atribui�ao correta dos bytes da mensagem
        // para o exemplo, envia o incremento do valor recebido e
        // atualizado na verifica��o
        
        // monto o array de retorno parConf:
        ret[0] =  (byte) ((this.step << 4 ) | (erro));
     	
        byte[] bytesIV = new byte[tamanhoIV];
        
		try {
			bytesIV = initializationArray.getBytes("UTF-8");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
     	
     	int j = 1;
     	for( int i=0; i < bytesIV.length; i++) {
     		ret[j] = bytesIV[i];
     		j++;
     	}
     				
        return ret;
    }
    
    private byte[] genThirdMessage(){    	
    	
    	String mensagemDeTexto = this.texto;
    	
    	int tamanhoTexto = mensagemDeTexto.length();
    	
    	int i = 0;
    	   	
    	/* [ALTERADO][COMPLETAR]
    	 * aqui eu vou enviar a mensagem, que suponho esta salva no atributo referente a mensagem,
    	 * pro servidor.Na realidade, devemos mandar a mensagem criptografada, e eu to
    	 * esperando que voce criptografe ela aqui antes do envio e salve na variavel "criptografada"
    	 * 
    	 * Lembra que o IV foi recebido e salvo num atributo no verifySecnondMessage (linha 265).
    	 */
    	byte[] criptografadaBytes = new byte[tamanhoTexto];
    	
    	// Vou converter de string para byte array:
    	try {
    		criptografadaBytes = mensagemDeTexto.getBytes("UTF-8");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
        
        // come�ar o prenchimento da mensagem "Dados":
    	
        // defini��o do tamanho da mensagem
        byte[] ret = new byte[3 + tamanhoTexto];
        
        // codigo de erro zero e tipo da mensagem no primeiro byte:
        ret[0] = (byte) ((this.tipo << 4) | 0);

        // tamanho da mensagem nos bytes 1 e 2:
        ret[1] = (byte) (mensagemDeTexto.length() >> 8);
        ret[2] = (byte) (mensagemDeTexto.length());
		
        // a partir dai, inserir a mensagem criptografada:
        int j = 3;
        for (i = 0; i < tamanhoTexto; i++) {
        	ret[j] = criptografadaBytes[i];
        	j++;
        } 
        
        return ret;
    }
    
    private byte[] genForthMessage(){
        
    	byte[] ret = new byte[1];
    	String criptografada = this.textoCriptografado;
    	
    	this.valor = this.valor+1;
    	boolean descriptografia =  true;
    	/* [COMPLETAR]
    	 * Aqui a gente tenta decifrar a mensagem criptorafada.
    	 * Alternativamente voce pode decifrar ela no validateThirdMessage, se achar que fica melhor...
    	 * Se conseguirmos validar, respondemos pro cliente confirmando 
    	 */
    	String descriptografada = criptografada;
    	
    	// adicionar validacao: this.tipo deve ser 4 aqui...
    	if(descriptografia) {
    		this.setMensagem(descriptografada);
    		ret[0] = (byte) ((4 << 4) | 0);
    	}
    		
 	/** codigo yeda **
    	// defini��o do tamanho da mensagem
        byte[] ret = new byte[2];
        // atualiza��o dos parametros internos do protocol
        this.valor = this.valor+1;
        // atribui�ao correta dos bytes da mensagem
        // para o exemplo, envia o incremento do valor recebido e
        // atualizado na verifica��o
        ret[0] = (byte)this.valor ;
        ret[1] = (byte)this.getErrorCode();
        **/
    	return ret;
    }
    
    private boolean verifyFirstMessage(byte[] msg){
    	this.algoritmo = ( msg[5] >> 4);
    	this.padding = (msg[5] & 15);
    	this.tipo = 1;
    	this.modo = (int) msg[6];
    	//System.out.println("verifyFirstMessage :::::::: validateParams");
    	
    	if (this.validateParams()) {
	    	System.out.println("[Par_req] algoritmo: " + this.algoritmo + ", padding: " + this.padding + ", tipo: " 
	    						+ this.tipo + " , modo: " + this.modo);
	    	
	        // atualiza��o do status do protocolo, para o caso de enviar mensagem de erro
	        this.errorMsg = false;
	        // atualiza o estado das informa��es recebidas
	        this.valor = (int)msg[0];
	        this.tipo = (int)msg[0];
	        
	        return true;
    	}
    	else {
    		this.setErrorCode(1);
    		return false;
    	}
    }

    private boolean verifySecondMessage(byte[] msg){
        
    	int i,j;
		//byte[] initializationArray = new byte[16];
    	
    	// mensagem, provavelmente, correta
        boolean ret = true;
        this.errorMsg = false;
        
        // decompõe mensagem nos parâmetros do protocolo para validação
        int tipo = (int) (msg[0] >> 4);
        int erro = (msg[0] & 15);
        

        // analisa se mensagem recebido é valida, ou seja, possui a estrutura
        // esperada para o protocolo, é integra, etc.
        if( erro != 0) {
        	System.out.println("[Par_conf] Tipo: " + tipo + ", Erro: " + erro );
        	
        	this.errorMsg = true;
        	ret = false;
        	this.setErrorCode(1);
        }
        else {
	        this.tipo = tipo;
	    	
	    	/*j = 1;
			for(i = 0; i < 16; i++) {
				initializationArray[i] = msg[j];
				j++;
			}*/
	        
	        byte[] initializationArray = new byte[16];
	        
			SecureRandom srandom = new SecureRandom();
			srandom.nextBytes(initializationArray);
			
			//IvParameterSpec ivspec = new IvParameterSpec(initializationArray);
			
			System.arraycopy(initializationArray, 0, msg, 1, 16);
		
			
			//System.out.println("ivspec ::::::::::::::::: " + Arrays.toString(initializationArray));
			
			this.initializationArray = initializationArray;
		
			
			//this.initializationArray = util.byteToString(ivspec);
			System.out.println("[Par_conf] Tipo: " + tipo + ", Erro: " + this.errorCode + ", IV: " + Arrays.toString(this.initializationArray));
        }
		
		return ret;
    }
    
    private boolean verifyThirdMessage(byte[] msg){
        int i,j = 0;
        int tamanhoMsg = msg.length;
        
        byte[] bytesMensagemCriptografada = new byte[tamanhoMsg];
        
    	for (i=3;i<tamanhoMsg; i++) {
    		bytesMensagemCriptografada[j] = msg[i];
    		j++;
    	}
    	
    	String mensagemCriptografada = util.byteToString(bytesMensagemCriptografada);
    	
    	System.out.println("[Dados] mensagem criptografada: " + mensagemCriptografada);
        
        this.encrypt(bytesMensagemCriptografada);
        
        //String mensagemCriptografada = 
    	
    	// recebo a mensagem criptografada do cliente:
    	//System.out.println("[Dados] mensagem criptografada: " + mensagemCriptografada);
    	
    	//this.setMensagemCriptografada(mensagemCriptografada);
    	
    	return true;
    	/** codigo yeda **
    	// mensagem, provavelmente, correta
        boolean ret = true;
        byte [] bStr;
        // decomp�es mensagem nos par�metros do protocolo para valida��o
        int recebido = (int)msg[0];
        int len = (int)msg[1];
        
        this.errorMsg = false;
        
        
        // analisa se mensagem recebido � valida, ou seja, possui a estrutura
        // esperada para o protocolo, � integra, etc.
        // para o exemplo, se corresponde ao incremento do valor enviado
        if (recebido == (this.valor+1)) {
            this.valor = recebido;
            if (len == (msg.length-2)){
                bStr = new byte[len];
                System.arraycopy(msg, 2, bStr, 0, len);
                this.texto = new String(bStr);
            } else {
                this.errorMsg = true;
                // atribuir o c�digo de erro para retorno, se existir
                this.setErrorCode(2);
                ret = false;
            }
        } else {
            this.errorMsg = true;
            ret = false;
            // atribuir o c�digo de erro para retorno, se existir
            this.setErrorCode(1);
        }
        return ret;
        **/
    }
    
    private boolean verifyForthMessage(byte[] msg){
        
    	boolean ret = false;
    	this.tipo = ( msg[0] >> 4);
    	int erro = (msg[0] & 15);
    	
    	// adicionar validacao de tipo e tratamento de erro
    	if(erro == 0) {
    		ret = true;
    	}
    	
    	
    	/** codigo yeda **
    	// mensagem, provavelmente, correta
        this.errorMsg = false;
        
        // decomp�es mensagem nos par�metros do protocolo para valida��o
        int recebido = (int)msg[0];
        
        // analisa se mensagem recebido � valida, ou seja, possui a estrutura
        // esperada para o protocolo, � integra, etc.
        // para o exemplo, se corresponde ao incremento do valor enviado
        if (recebido == (this.valor+1)) {
            this.valor = recebido;
        } else {
            this.errorMsg = true;
            ret = false;
            // atribuir o c�digo de erro para retorno, se existir
            this.setErrorCode((int)msg[1]);
        }
        **/
        return ret;
    }
    
    /**
     * Este m�todo informa ao RunProtocol o tamanho do cabe�alho
     * para leitura
     * @return 
     */
    public int getHeaderLenght() {
        int ret = 0;
        // Precisa reconhecer o tipo da mensagem e saber o tamanho
        // do cabe�alho e payload para leitura pelo RunProtocol
        //System.out.println("STEP: " + this.getStep());
        switch (this.getStep()) {
            case 0: ret = 1;break;
            case 1: ret = 1;break;
            case 2: ret = 3;break;
            case 3: ret = 2;break;
        }
        
        return ret;
    }

    /**
     * Este m�todo informa ao RunProtocol o tamanho do payload
     * Em mensagens de tamanho vari�vel esta informa��o est� no cabe�alho
     * @param header
     * @return 
     */
    public int getPayloadLenght(byte[] header) {
        int ret = 0;
        // precisa reconhecer o tipo da mensagem e saber o tamanho
        // do cabe�alho e payload 
        
        switch (this.getStep()) {
            case 0: ret = 6;break;
            case 1: ret = 16;break;
            case 2: ret =  ((header[1] << 4 ) | (header[2]));
                    //System.out.println("Header: "+header[1]);
                    break;
            case 3: ret = 1;break;
        }
        return ret;
    }
    
    public String getMensagem(){
        return this.texto;
    }
    
    /**
     * Este m�todo � espec�fico deste exemplo
     * @param vlr 
     */
    public void setValor(int vlr){
        if (this.mode == CLIENT) {
            this.valor = vlr;
        }
    }
    
    public void setMensagem(String texto){
    	this.texto = texto;
    }
    
    public void setMensagemCriptografada(String texto){
        if (this.mode == SERVER) {
            this.textoCriptografado = texto;
        }
    }
    
    public void setAlgoritmo(byte algoritmo) {
    	if (this.mode == CLIENT) {
            this.algoritmo = algoritmo;
        }
    }
    
    public void setPadding(byte padding) {
    	if (this.mode == CLIENT) {
            this.padding = padding;
        }
    }
    
    public void setModo(int modo) {
    	if (this.mode == CLIENT) {
            this.modo = modo;
        }
    }
    
    public void setErrorCode(int error) {
    	this.errorCode = error;
    }

    // --------------------------------------
    // CRIPTOGRAFIA
    // --------------------------------------

    public static final HashMap<Integer, String> algMap = new HashMap<Integer, String>();
	{
		algMap.put(0, "AES128"); // AES com chave de 128 bits
		algMap.put(1, "AES192"); // AES com chave de 192 bits
		algMap.put(2, "AES256"); // AES com chave de 256 bits
		algMap.put(3, "DES"); // DES
		algMap.put(4, "3DES-EDE2"); // Triple-DES no modo EDE com duas chaves
		algMap.put(5, "3DES-EDE3"); // Triple-DES no modo EDE com três chaves
	};
	public static final HashMap<Integer, String> modeMap = new HashMap<Integer, String>();
	{
		modeMap.put(0, "ECB"); // Electronic Codebook Book
		modeMap.put(1, "CBC"); // Cipher Block Chaining
		modeMap.put(2, "CFB1"); // Cipher FeedBack com deslocamento de 1 bit (S)
		modeMap.put(3, "CFB8"); // Cipher FeedBack com deslocamento de 1 byte (S)
		modeMap.put(4, "CFB64"); // Cipher FeedBack com deslocamento de 8 bytes (S)
		modeMap.put(5, "CFB128"); // Cipher FeedBack com deslocamento de 16 bytes (S)
		modeMap.put(6, "CTR"); // Counter
	};
	public static final HashMap<Integer, String> padMap = new HashMap<Integer, String>();
	{
		padMap.put(0, "NoPadding"); // Sem preenchimento
		padMap.put(1, "PKCS5Padding"); // Preenchimento no padrão PKCS5
	};
	
	// verifica se suporta os parâmetros
	public boolean validateParams() {
		if (!algMap.containsKey(this.algoritmo)) {
			//System.out.println("validateParams :::::::: alg false");
			return false;
		}
		if (!modeMap.containsKey(this.modo)) {
			//System.out.println("validateParams :::::::: mode false");
			return false;
		}
		if (!padMap.containsKey(this.padding)) {
			//System.out.println("validateParams :::::::: pad false");
			return false;
		}
		
		//System.out.println("validateParams :::::::: true");
		
		return true;
	}

	public String cryptoInstance() {
		String ret;

		/*ret = algMap.get(new Integer(this.algoritmo)) + "/" + modeMap.get(new Integer(this.modo)) + "/"
				+ padMap.get(new Integer(this.padding));*/
		
		ret = "AES/" + modeMap.get(new Integer(this.modo)) + "/"
				+ padMap.get(new Integer(this.padding));
		return ret;
	}
	
	public void encrypt(byte[] msg) {
		byte[] initializationArray = new byte[16];
        
		SecureRandom srandom = new SecureRandom();
		srandom.nextBytes(initializationArray);
		
		IvParameterSpec ivspec = new IvParameterSpec(initializationArray);
		
		try {
			KeyGenerator kgen = KeyGenerator.getInstance("AES");
			SecretKey skey = kgen.generateKey();
			SecretKeySpec skeyspec = new SecretKeySpec(skey.getEncoded(), "AES");
			
			Cipher ci = Cipher.getInstance(this.cryptoInstance());
			ci.init(Cipher.ENCRYPT_MODE, skeyspec, ivspec);
			
			this.cipher = ci;
			
			//String msg = "testando";
			
			//System.out.println("Mensagem normal: " + msg);
			
			//byte[] input = msg.getBytes("UTF-8");
			byte[] encoded = ci.doFinal(msg);
			
			System.out.println("Mensagem criptografa: " + encoded);
			
			this.decrypt(encoded);
			
		} catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {
			e.printStackTrace();
		}
	}
	
	public void decrypt(byte[] encoded) {
		//byte[] encoded = Files.readAllBytes(Paths.get(inFile));
		try {
			String plainText = new String(this.cipher.doFinal(encoded), "UTF-8");
			
			System.out.println("Mensagem descriptografa: " + plainText);
		} catch (UnsupportedEncodingException | IllegalBlockSizeException | BadPaddingException e) {
			e.printStackTrace();
		}
	}
}
