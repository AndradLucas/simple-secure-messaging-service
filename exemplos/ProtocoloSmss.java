/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package exemplos;

import protocols.ProtocolModel;
import util.Util;

/**
 * Suponha que o protocolo deve trocar 4 mensagens.
 * Cliente envia byte de valor X
 * Servidor retorna byte de valor X+1
 * Cliente envia byte de valor (X+2)+tamanho da mensagem(1 bytes)+mensagem de texto
 * Servidor retorna byte de valor (X+3)+1 byte de código de erro (ou zero se sucesso)
 * Código de erro: 1 para erro no indice X+i e 2 para erro na mensagem ou tamanho
 * @author yeda
 */
public class ProtocoloSmss extends ProtocolModel {
    private int valor = 0;
    private boolean errorMsg = false;
    
    private String texto = "Texto nao obtido ainda";
    private String initializationArray = "iv nao iniciado ainda";
    /* dados do protocolo smss: */
    private int origem = 743563;
    private int destino = 743563;
    private int tipo = 0;
    private int algoritmo = -1;
    private int padding = -1;
    private int modo = -1;
    
    public Util util;
    
    
    /**
     * Servidor e cliente no modo padrão.
     * 
     * @param mode
     */
    ProtocoloSmss(int mode) {
        // gera um protocolo com 4 mensagens, alternando entre enviar e receber
        // Modo cliente, inicia com enviar, e modo servidor, incia com receber
        super(mode, 4);
    }
    
    /**
    * Este método deve retornar as mensagens exatamente como especificado
    * pelo protocolo. 
    * Cliente gera as mensagens: 0 e 2
    * Servidor gera as mensagens: 1 e 3
    * Todas as mensagens geradas são implementadas nesta classe, nos
    * respectivos métodos privados gen??Message()
    * Obs.:Para um protocolo de 4 mensagens este método não precisa ser editado
    */
    protected byte[] nextMessage() {
        byte[] msg = null;
        switch (this.step) {
            case 0:
                //First message, generated by the CLIENT
            	// Par_req
                msg = this.genFirstMessage();
                System.out.println("[Par_req] Primeira Msg sent...");
                //Util.viewHex(msg);
                break;
            case 1:
                //Second message, genereted by the SERVER
                msg = this.genSecondMessage();
                System.out.println("Segunda Msg sent...");
                //Util.viewHex(msg);
                break;
            case 2:
                //Third message, generated by the CLIENT
                msg = this.genThirdMessage();
                System.out.println("Terceira Msg sent...");
                //Util.viewHex(msg);
                break;
            case 3:
                //Third message, generated by the CLIENT
                msg = this.genForthMessage();
                System.out.println("Quarta Msg sent...");
                //Util.viewHex(msg);
                break;
        }
        
        return msg;
    }

    /**
    * Este método valida se as mensagens recebidas são exatamente como
    * especificado pelo protocolo. 
    * Cliente valida as mensagens: 1 e 3
    * Servidor valida as mensagens: 0 e 2
    * Todas as validações de mensagens são implementadas nesta classe, nos
    * respectivos métodos privados verify??Message()
    * Obs.:Para um protocolo de 4 mensagens este método não precisa ser editado
    */
    protected boolean verifyMessage(byte[] receivedMsg) {
        boolean ret = false;
        switch (this.step) {
            case 0:
                //Verify First message, performed by the SERVER
                ret = this.verifyFirstMessage(receivedMsg);
                System.out.println("Primeira Msg ... " + ret);
                break;
            case 1:
                //Verify Second message, performed by the CLIENT
                ret = this.verifySecondMessage(receivedMsg);
                System.out.println("Segunda Msg ... " + ret);
                break;
            case 2:
                //Verify Third message, performed by the SERVER
                ret = this.verifyThirdMessage(receivedMsg);
                System.out.println("Terceira Msg ... " + ret);
                break;
            case 3:
                //Verify Third message, performed by the SERVER
                ret = this.verifyForthMessage(receivedMsg);
                System.out.println("Terceira Msg ... " + ret);
                break;
        }
        
        return ret;
    }

    private byte[] genFirstMessage(){
        // definição do tamanho da mensagem
        byte[] ret = new byte[7];
        // atribuiçao correta dos bytes da mensagem
        // para o exemplo, envia um número qualquer de 1 byte
        // valor deve ser definido em setMessage()
        
        //ret[0] = (byte)this.valor;
        
        /* [ALTERADO] */
        ret[0] = (byte) this.tipo;
        ret[1] = (byte) (this.origem >> 8);
        ret[2] = (byte) (this.origem);
        ret[3] = (byte) (this.destino >> 8);
        ret[4] = (byte) (this.destino);
        ret[5] = (byte) ((this.algoritmo << 4 ) | (this.padding));
        ret[6] = (byte) (this.modo);
        
        
        
        return ret;
    }
    
    private byte[] genSecondMessage(){
        // definição do tamanho da mensagem
        byte[] ret = new byte[17];
        int erro;
        
        /* [ALTERADO][COMPLETAR]
         * Aqui precisamos responder pro cliente informando ou a chave de seguranca, ou  o codigo de erro.
         * Voce precisa ver qual criterio de criptografia vai querer aceitar, abaixo faço uma checagem
         * bem basica.
         * 
         * Voce tambem precisa gerar o IV  enfiar no vetor de mesmo nome:
         */
        String initializationArray = "pspspspspspspsps";
        
        if( this.modo == 5 && this.algoritmo == 0 && this.padding == 0) {
        	erro = 0;
        }else {
        	erro = 1;
        }
        
        // atualização dos parametros internos do protocol
        this.valor = this.valor+1;
        // atribuiçao correta dos bytes da mensagem
        // para o exemplo, envia o incremento do valor recebido e
        // atualizado na verificação
        
        // monto o array de retorno parConf:
        ret[0] =  (byte) ((this.step << 4 ) | (erro));
     	
		 StringBuffer sb = new StringBuffer();
		        
		        //Converting string to character array
		 char ch[] = initializationArray.toCharArray();
		 for(int i = 0; i < ch.length; i++) {
			 String hexString = Integer.toHexString(ch[i]);
		     sb.append(hexString);
		 }
		 
		 String hexIV = sb.toString();
		 //System.out.println(result);

     	byte[] bytesIV = new byte[16];
     	bytesIV = util.hexToByte(hexIV);
     	
     	int j = 1;
     	for( int i=0; i < bytesIV.length; i++) {
     		ret[j] = bytesIV[i];
     		j++;
     	}
     				
        return ret;
    }
    
    private byte[] genThirdMessage(){
        // definição do tamanho da mensagem
        byte[] ret = new byte[2+this.texto.length()];
        // atualização dos parametros internos do protocol
        this.valor = this.valor+1;
        // atribuiçao correta dos bytes da mensagem
        // para o exemplo, envia o incremento do valor recebido e
        // atualizado na verificação
        ret[0] = (byte)this.valor ;
        ret[1] = (byte)this.texto.length();
        System.arraycopy(this.texto.getBytes(), 0, ret, 2, this.texto.length());
        //System.out.println(new String(ret));
        
        return ret;
    }
    
    private byte[] genForthMessage(){
        // definição do tamanho da mensagem
        byte[] ret = new byte[2];
        // atualização dos parametros internos do protocol
        this.valor = this.valor+1;
        // atribuiçao correta dos bytes da mensagem
        // para o exemplo, envia o incremento do valor recebido e
        // atualizado na verificação
        ret[0] = (byte)this.valor ;
        ret[1] = (byte)this.getErrorCode();
        
        return ret;
    }
    
    private boolean verifyFirstMessage(byte[] msg){
    	
    	// VALIDAR OS PARAMETROS DE CRIPTOGRAFIA:
    	this.algoritmo = ( msg[5] >> 4);
    	this.padding = (msg[5] & 15);
    	this.tipo = 1;
    	this.modo = (int) msg[6];
    	System.out.println("[Par_req] comprimento msg: " + msg.length);
    	System.out.println("[Par_req] algoritmo: " + this.algoritmo + ", padding: " + this.padding + ", tipo: " 
    						+ this.tipo + " , modo: " + this.modo);
    	
        // 1a mensagem sempre correta
        boolean ret = true;
        // atualização do status do protocolo, para o caso de enviar mensagem de erro
        this.errorMsg = false;
        // atualiza o estado das informações recebidas
        this.valor = (int)msg[0];
        this.tipo = (int)msg[0];
        
        return ret;
    }

    private boolean verifySecondMessage(byte[] msg){
        
    	int i,j;
		byte[] initializationArray = new byte[16];
    	
    	// mensagem, provavelmente, correta
        boolean ret = true;
        this.errorMsg = false;
        
        // decompões mensagem nos parâmetros do protocolo para validação
        int tipo = (int) (msg[0] >> 4);
        int erro = (msg[0] & 15);
        
        System.out.print("[Par_conf] Tipo: " + tipo + ", Erro: " + erro );

        // analisa se mensagem recebido é valida, ou seja, possui a estrutura
        // esperada para o protocolo, é integra, etc.
        if( erro != 0) {
        	this.errorMsg = true;
        	ret = false;
        	this.setErrorCode(1);
        } else {
        	this.tipo = tipo;
        	
        	j = 1;
    		for(i = 0; i < 16; i++) {
    			initializationArray[i] = msg[j];
    			j++;
    		}
    		
    		this.initializationArray = util.byteToString(initializationArray);
    		System.out.print(", IV: " + this.initializationArray);
        }

        return ret;
    }
    
    private boolean verifyThirdMessage(byte[] msg){
        // mensagem, provavelmente, correta
        boolean ret = true;
        byte [] bStr;
        // decompões mensagem nos parâmetros do protocolo para validação
        int recebido = (int)msg[0];
        int len = (int)msg[1];
        
        this.errorMsg = false;
        // analisa se mensagem recebido é valida, ou seja, possui a estrutura
        // esperada para o protocolo, é integra, etc.
        // para o exemplo, se corresponde ao incremento do valor enviado
        if (recebido == (this.valor+1)) {
            this.valor = recebido;
            if (len == (msg.length-2)){
                bStr = new byte[len];
                System.arraycopy(msg, 2, bStr, 0, len);
                this.texto = new String(bStr);
            } else {
                this.errorMsg = true;
                // atribuir o código de erro para retorno, se existir
                this.setErrorCode(2);
                ret = false;
            }
        } else {
            this.errorMsg = true;
            ret = false;
            // atribuir o código de erro para retorno, se existir
            this.setErrorCode(1);
        }
        return ret;
    }
    
    private boolean verifyForthMessage(byte[] msg){
        // mensagem, provavelmente, correta
        boolean ret = true;
        this.errorMsg = false;
        
        // decompões mensagem nos parâmetros do protocolo para validação
        int recebido = (int)msg[0];
        
        // analisa se mensagem recebido é valida, ou seja, possui a estrutura
        // esperada para o protocolo, é integra, etc.
        // para o exemplo, se corresponde ao incremento do valor enviado
        if (recebido == (this.valor+1)) {
            this.valor = recebido;
        } else {
            this.errorMsg = true;
            ret = false;
            // atribuir o código de erro para retorno, se existir
            this.setErrorCode((int)msg[1]);
        }
        return ret;
    }
    
    /**
     * Este método informa ao RunProtocol o tamanho do cabeçalho
     * para leitura
     * @return 
     */
    public int getHeaderLenght() {
        int ret = 0;
        // Precisa reconhecer o tipo da mensagem e saber o tamanho
        // do cabeçalho e payload para leitura pelo RunProtocol
        //System.out.println("STEP: " + this.getStep());
        switch (this.getStep()) {
            case 0: ret = 1;break;
            case 1: ret = 1;break;
            case 2: ret = 3;break;
            case 3: ret = 1;break;
        }
        
        return ret;
    }

    /**
     * Este método informa ao RunProtocol o tamanho do payload
     * Em mensagens de tamanho variável esta informação está no cabeçalho
     * @param header
     * @return 
     */
    public int getPayloadLenght(byte[] header) {
        int ret = 0;
        // precisa reconhecer o tipo da mensagem e saber o tamanho
        // do cabeçalho e payload 
        
        switch (this.getStep()) {
            case 0: ret = 6;break;
            case 1: ret = 16;break;
            case 2: ret =  ((header[1] << 4 ) | (header[2]));
                    //System.out.println("Header: "+header[1]);
                    break;
            case 3: ret = 1;break;
        }
        return ret;
    }
    
    public String getMensagem(){
        return this.texto;
    }
    
    /**
     * Este método é específico deste exemplo
     * @param vlr 
     */
    public void setValor(int vlr){
        if (this.mode == CLIENT) {
            this.valor = vlr;
        }
    }
    
    public void setMensagem(String texto){
        if (this.mode == CLIENT) {
            this.texto = texto;
        }
    }
    
    public void setAlgoritmo(byte algoritmo) {
    	if (this.mode == CLIENT) {
            this.algoritmo = algoritmo;
        }
    }
    
    public void setPadding(byte padding) {
    	if (this.mode == CLIENT) {
            this.padding = padding;
        }
    }
    
    public void setModo(int modo) {
    	if (this.mode == CLIENT) {
            this.modo = modo;
        }
    }
}
